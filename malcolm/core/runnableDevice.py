import abc

from enum import Enum

from .method import wrap_method
from .base import weak_method
from .device import Device
from .stateMachine import StateMachine
from .attribute import Attribute
from .vtype import VBool


class DState(Enum):
    # These are the states that our machine supports
    Fault, Idle, Configuring, Ready, Running, Pausing, Paused, Aborting,\
        Aborted, Resetting = range(10)

    @classmethod
    def rest(cls):
        return [cls.Fault, cls.Idle, cls.Ready, cls.Aborted]

    @classmethod
    def donePause(cls):
        return [cls.Fault, cls.Aborted, cls.Paused]

    @classmethod
    def canAbort(cls):
        return [cls.Configuring, cls.Ready, cls.Running, cls.Pausing,
                cls.Paused, cls.Resetting]

    @classmethod
    def canConfig(cls):
        return [cls.Idle, cls.Ready]

    @classmethod
    def canRun(cls):
        return [cls.Ready, cls.Paused]

    @classmethod
    def canReset(cls):
        return [cls.Fault, cls.Aborted]

    def to_dict(self):
        return self.name


class DEvent(Enum):
    # These are the messages that we will respond to
    Error, Reset, ResetSta, Config, ConfigSta, Run, RunSta, Abort, AbortSta, \
        Pause, PauseSta = range(11)


class RunnableDevice(Device):

    def __init__(self, name, timeout=None):
        # superclass init
        super(RunnableDevice, self).__init__(name, timeout=timeout)

        # Make a statemachine
        sm = StateMachine(name + ".stateMachine", DState.Idle, DState.Fault)
        self.add_stateMachine(sm)

        # Override the error handler of the stateMachine
        sm.do_error = weak_method(self.do_error)

        # some shortcuts for the state table
        do, t, s, e = self.shortcuts(DState, DEvent)

        # Error condition generated by device
        t(s,             e.Error,     do.error,     s.Fault)
        # Normal operations
        t(s.canReset(),  e.Reset,     do.reset,     s.Resetting)
        t(s.Resetting,   e.ResetSta,  do.resetsta,  s.Resetting, s.Idle)
        t(s.canConfig(), e.Config,    do.config,    s.Configuring)
        t(s.Configuring, e.ConfigSta, do.configsta, s.Configuring, s.Ready)
        t(s.Ready,       e.Run,       do.run,       s.Running)
        t(s.Running,     e.RunSta,    do.runsta,    s.Running, s.Idle, s.Ready)
        # Abort
        t(s.canAbort(),  e.Abort,     do.abort,     s.Aborting)
        t(s.Aborting,    e.AbortSta,  do.abortsta,  s.Aborting, s.Aborted)

        # Add post_ methods
        self.add_post_methods(list(DEvent))

    def add_all_attributes(self):
        super(RunnableDevice, self).add_all_attributes()
        # Timeout for functions
        self.add_attributes(
            block=Attribute(
                VBool, "Whether to wait for a function to complete"))

    def do_error(self, error):
        """Handle an error"""
        return DState.Fault, str(error)

    @abc.abstractmethod
    def do_config(self, **config_params):
        """Start doing a configuration using config_params, arranging for a
        callback doing self.post_configsta(configsta) when progress has
        been made, where configsta is any device specific configuration status
        """

    @abc.abstractmethod
    def do_configsta(self, configsta):
        """Examine configsta for configuration progress, returning
        DState.Configuring if still in progress, or DState.Ready if done.
        """

    @abc.abstractmethod
    def do_run(self):
        """Start doing a run, arranging for a callback doing
        self.post_runsta(runsta) when progress has been made, where
        runsta is any device specific run status
        """

    @abc.abstractmethod
    def do_runsta(self, runsta):
        """Examine runsta for run progress, returning DState.Running if still
        in progress, DState.Ready if done and another run can be started
        without reconfiguration, or DState.Idle if done and configuration is
        needed before another run can be started.
        """

    @abc.abstractmethod
    def do_abort(self):
        """Start doing an abort, arranging for a callback doing
        self.post_abortsta(abortsta) when progress has been made, where
        abortsta is any device specific abort status
        """

    @abc.abstractmethod
    def do_abortsta(self, abortsta):
        """Examine abortsta for abort progress, returning DState.Aborting if still
        in progress or DState.Aborted if done.
        """

    @abc.abstractmethod
    def do_reset(self):
        """Check and attempt to clear any error state, arranging for a
        callback doing self.post_resetsta(resetsta) when progress has
        been made, where resetsta is any device specific reset status
        """

    @abc.abstractmethod
    def do_resetsta(self, resetsta):
        """Examine configsta for configuration progress, returning
        DState.Resetting if still in progress, or DState.Idle if done.
        """

    def _get_default_times(self, funcname=None):
        # If we have a cached version, use this
        if not hasattr(self, "_default_times"):
            self._default_times = dict(
                abortTimeout=1,
                resetTimeout=1,
                configureTimeout=1,
                runTimeout=1,
                runTime=None,
            )
        if funcname is None:
            return self._default_times
        else:
            return self._default_times[funcname + "Timeout"]

    @abc.abstractmethod
    def validate(self, params):
        """Check whether a set of configuration parameters is valid or not. Each
        parameter name must match one of the names in self.attributes. This set
        of parameters should be checked in isolation, no device state should be
        taken into account. It is allowed from any DState and raises an error
        if the set of configuration parameters is invalid. It should return
        some metrics on the set of parameters as well as the actual parameters
        that should be used, e.g.
        {"runTime": 1.5, arg1=2, arg2="arg2default"}
        """
        times = self._get_default_times()
        # get rid of unrecognised keys
        for key in params.keys():
            if key not in self.configure.arguments and key not in times:
                if "timeout" in key.lower():
                    self.log_warning(
                        "Possible mis-spelt keyword {}. Could be one of {}"
                        .format(key, times.keys()))
                params.pop(key)
        # add in default times
        for key, time in times.items():
            if key not in params:
                params[key] = time
        return params

    @wrap_method(only_in=DState.canConfig(), arguments_from=validate)
    def configure(self, block=True, **params):
        """Assert params are valid, then use them to configure a device for a run.
        It blocks until the device is in a rest state:
         * Normally it will return a DState.Configured Status
         * If the user aborts then it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        params = self.validate(**params)
        # update default timeouts from results
        default_times = self._get_default_times()
        for key in default_times:
            if key in params:
                default_times[key] = params.pop(key)
        # clamp runTimeout
        if default_times["runTimeout"] < default_times["runTime"]:
            default_times["runTimeout"] = default_times["runTime"] * 2
        self.post_config(**params)
        if block:
            timeout = self._get_default_times("configure")
            self.wait_until(DState.rest(), timeout=timeout)

    @wrap_method(only_in=DState.canRun())
    def run(self, block=True):
        """Start a configured device running. It blocks until the device is in a
        rest state:
         * Normally it will return a DState.Idle Status
         * If the device allows many runs from a single configure the it
           will return a DState.Ready Status
         * If the user aborts then it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.post_run()
        if block:
            timeout = self._get_default_times("run")
            self.wait_until(DState.rest(), timeout=timeout)
            # TODO: timeout handling for paused

    @wrap_method(only_in=DState.canAbort())
    def abort(self, block=True):
        """Abort configuration or abandon the current run whether it is
        running or paused. It blocks until the device is in a rest state:
         * Normally it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.post_abort()
        if block:
            timeout = self._get_default_times("abort")
            self.wait_until(DState.rest(), timeout=timeout)

    @wrap_method(only_in=DState.canReset())
    def reset(self, block=True):
        """Try and reset the device into DState.Idle. It blocks until the
        device is in a rest state:
         * Normally it will return a DState.Idle Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.post_reset()
        if block:
            timeout = self._get_default_times("reset")
            self.wait_until(DState.rest(), timeout=timeout)
